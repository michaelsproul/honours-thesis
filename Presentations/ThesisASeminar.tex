\documentclass[10pt]{beamer}

\usepackage{proof}

\usetheme[everytitleformat=regular,progressbar=foot]{m}

\usepackage{booktabs}
\usepackage[scale=2]{ccicons}

\title{Formalising a language with uniqueness typing}
\author{Michael Sproul}
\date{}
\institute{
    Supervisor: Ben Lippmeier\\
    University of New South Wales
}

\begin{document}

\maketitle

\section{Introduction}

\begin{frame}{What?}

\begin{enumerate}
\item Define the \textit{type system} and \textit{semantics} for a small programming language as a formal mathematical system.
\item Prove that the programming language is ``well-behaved" -- \textit{sound}.
\end{enumerate}
\end{frame}

\begin{frame}
{Motivation}

Programming languages are complicated, lots of interacting features.

We want to:

\begin{itemize}
\item Eliminate or minimise undefined behaviour.

% Do closures work well with exceptions? 
\item Ensure that language features interoperate without creating unsoundness.

\item Provide a solid foundation for software verification.

\end{itemize}
\end{frame}

\begin{frame}
{Motivation}

Formalised language semantics are a prerequisite for:

\begin{itemize}
\item Proofs about programs. \textit{seL4}, verified crypto.
    \begin{itemize}
    \item Security, correctness, speed (?)
    \end{itemize}
\item Trust-worthy compilers. \textit{CompCert}.
\item Sanity whilst programming?
\end{itemize}
\end{frame}

\section{Background}

\begin{frame}{Contraction and Weakening}

In regular* logic there are two rules that allow assumptions to be discarded or introduced from nowhere:

$$
\infer[Contraction]{\Gamma, A \vdash B}{
	\Gamma, A, A \vdash B
}
\qquad
\infer[Weakening]{\Gamma, A \vdash B}{
    \Gamma \vdash B
}
$$

*regular = classical/intuitionistic/constructive

\end{frame}

\begin{frame}{Contraction and Weakening}

Every logic corresponds to a type system, so we have...

\begin{eqnarray*}
\infer[Contraction]{\Gamma, x : A \vdash u[x/y, x/z] :: B}{
	\Gamma, y : A, z : A \vdash u :: B
}
\qquad
\infer[Weakening]{\Gamma, x : A \vdash y :: B}{
    \Gamma\vdash y :: B
}
\end{eqnarray*}

Without contraction, variables can only appear once in a term.
% Note: This is because concatenation of environments requires distinct variables.

Without weakening, all variables in the context must be used in the term.

[Wadler, 1991, 1993]

\end{frame}

\begin{frame}{Linear and affine type systems}

\begin{itemize}
\item \textbf{Linear type system:} Contraction and weakening banned -- every value used \textit{exactly} once.
\item \textbf{Affine type system:} Contraction banned, weakening allowed -- every value used \textit{at most} once.
\end{itemize}

From linear logic [Girard, 1987] and affine logic [Grishin, 1974] respectively.

Both type systems allow some terms to be treated in the normal intuitionistic way, via the ! (bang) operator.

\end{frame}

\begin{frame}{Why bother?}

Linear values

\begin{itemize}
\item Alternative way to model I/O, instead of Monads.
\item Efficient mutation in pure functional languages.
\item Avoid garbage collection. Compete with C and C++.
\end{itemize}




\end{frame}

\begin{frame}{Why Uniqueness Typing?}

\end{frame}

\section{Proposal}

\begin{frame}{Proposal}

Define operational semantics and typing rules for a variant of the lambda calculus with \textit{linear} typing, in Coq, using de Bruijn indices for naming.

Prove \textit{progress} and \textit{preservation}.
\end{frame}

\begin{frame}{Progress}

If a term is well-typed, it is either a value, or it can take a step.

[[formal definition here (gotta workout Latex natural deduction)]]
\end{frame}

\begin{frame}{Preservation}

If a term is well-typed and it takes a step, it retains the same type.

\end{frame}

\end{document}